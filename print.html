<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Oura</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="installation/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation/binary_release.html"><strong aria-hidden="true">2.1.</strong> Binary Release</a></li><li class="chapter-item expanded "><a href="installation/from_source.html"><strong aria-hidden="true">2.2.</strong> From Source</a></li><li class="chapter-item expanded "><a href="installation/docker.html"><strong aria-hidden="true">2.3.</strong> Docker</a></li><li class="chapter-item expanded "><a href="installation/kubernetes.html"><strong aria-hidden="true">2.4.</strong> Kubernetes</a></li></ol></li><li class="chapter-item expanded "><a href="usage/index.html"><strong aria-hidden="true">3.</strong> Usage</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/watch.html"><strong aria-hidden="true">3.1.</strong> Watch Mode</a></li><li class="chapter-item expanded "><a href="usage/daemon.html"><strong aria-hidden="true">3.2.</strong> Daemon Mode</a></li><li class="chapter-item expanded "><a href="usage/library.html"><strong aria-hidden="true">3.3.</strong> Library</a></li></ol></li><li class="chapter-item expanded "><a href="filters/index.html"><strong aria-hidden="true">4.</strong> Filters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="filters/fingerprint.html"><strong aria-hidden="true">4.1.</strong> Fingerprint</a></li><li class="chapter-item expanded "><a href="filters/selection.html"><strong aria-hidden="true">4.2.</strong> Selection</a></li></ol></li><li class="chapter-item expanded "><a href="sources/index.html"><strong aria-hidden="true">5.</strong> Sources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sources/n2n.html"><strong aria-hidden="true">5.1.</strong> Node-to-Node</a></li><li class="chapter-item expanded "><a href="sources/n2c.html"><strong aria-hidden="true">5.2.</strong> Node-to-Client</a></li></ol></li><li class="chapter-item expanded "><a href="sinks/index.html"><strong aria-hidden="true">6.</strong> Sinks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sinks/terminal.html"><strong aria-hidden="true">6.1.</strong> Terminal</a></li><li class="chapter-item expanded "><a href="sinks/kafka.html"><strong aria-hidden="true">6.2.</strong> Kafka</a></li><li class="chapter-item expanded "><a href="sinks/elastic.html"><strong aria-hidden="true">6.3.</strong> Elasticsearch</a></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">7.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/data_dictionary.html"><strong aria-hidden="true">7.1.</strong> Data Dictionary</a></li></ol></li><li class="chapter-item expanded "><a href="guides/index.html"><strong aria-hidden="true">8.</strong> Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/cardano_2_kafka.html"><strong aria-hidden="true">8.1.</strong> Cardano =&gt; Kafka</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Oura</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>We have tools to &quot;explore&quot; the Cardano blockchain, which are useful when you know what you're looking for. We argue that there's a different, complementary use-case which is to &quot;observe&quot; the blockchain and react to particular event patterns.</p>
<p><em>Oura</em> is a rust-native implementation of a pipeline that connects to the tip of a Cardano node through a combination of <em>Ouroboros</em> mini-protocol (using either a unix socket or tcp bearer), filters the events that match a particular pattern and then submits a succint, self-contained payload to pluggable observers called &quot;sinks&quot;.</p>
<h2 id="etymology"><a class="header" href="#etymology">Etymology</a></h2>
<p>The name of the tool is inspired by the <code>tail</code> command available in unix-like systems which is used to display the tail end of a text file or piped data. Cardano's consensus procotol name, <em>Ouroboros</em>, is a reference to the ancient symbol depicting a serpent or dragon eating its own tail, which means &quot;tail eating&quot;. &quot;Oura&quot; is the ancient greek word for &quot;tail&quot;.</p>
<h2 id="under-the-hood"><a class="header" href="#under-the-hood">Under the Hood</a></h2>
<p>All the heavy lifting required to communicate with the Cardano node is done by the <a href="https://github.com/txpipe/pallas">Pallas</a> library, which provides an implementation of the Ouroboros multiplixer and a few of the required mini-protocol state-machines (ChainSync and LocalState in particular).</p>
<p>The data pipeline makes heavy use (maybe a bit too much) of multi-threading and mpsc channels provided by Rust's <code>std::sync</code> library.</p>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="cli-to-watch-live-transactions"><a class="header" href="#cli-to-watch-live-transactions">CLI to Watch Live Transactions</a></h3>
<p>You can run <code>oura watch &lt;socket&gt;</code> to print TX data into the terminal from the tip of a local or remote node. It can be useful as a debugging tool for developers or if you're just curious to see whats going on in the network (for example, to see airdrops as they happen or oracles posting new information).</p>
<h3 id="as-a-bridge-to-other-persistence-mechanisms"><a class="header" href="#as-a-bridge-to-other-persistence-mechanisms">As a Bridge to Other Persistence Mechanisms</a></h3>
<p>Similar to the well-known db-sync tool provided by IOHK, <em>Oura</em> can be used as a daemon to follow a node and output the data into a different data storage techonology more suited for your final use-case. The main difference with db-sync is that <em>Oura</em> was designed for easy integration with data-streaming pipelines instead of relational databases.</p>
<p>Given its small memory / cpu footprint, <em>Oura</em> can be deployed side-by-side with your Cardano node even in resource-constrained environments, such as Raspberry PIs.</p>
<h3 id="as-a-trigger-of-custom-actions"><a class="header" href="#as-a-trigger-of-custom-actions">As a Trigger of Custom Actions</a></h3>
<p><em>Oura</em> running in <code>daemon</code> mode can be configured to use custom filters to pinpoint particular transaction patterns and trigger actions whenever it finds a match. For example: send an email when a particular policy / asset combination appears in a transaction; call an AWS Lambda function when a wallet delegates to a particular pool; send a http-call to a webhook each time a metadata key appears in the TX payload;</p>
<h3 id="as-a-library-for-custom-scenarios"><a class="header" href="#as-a-library-for-custom-scenarios">As a Library for Custom Scenarios</a></h3>
<p>If the available out-of-the-box features don't satisfiy your particular use-case, <em>Oura</em> can be used a library in your Rust project to setup tailor-made pipelines. Each component (sources, filters, sinks, etc) in <em>Oura</em> aims at being self-contained and reusable. For example, custom filters and sinks can be built while reusing the existing sources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Depending on your needs, <em>Oura</em> provides different installation options:</p>
<ul>
<li><a href="installation/binary_release.html">Binary Release</a>: to use one of our pre-compiled binary releases for the supported platforms.</li>
<li><a href="installation/from_source.html">From Source</a>: to compile a binary from source code using Rust's toolchain</li>
<li><a href="installation/docker.html">Docker</a>: to run the tool from a pre-built docker image</li>
<li><a href="installation/kubernetes.html">Kubernetes</a>: to deploy <em>Oura</em> as a resource within a Kuberentes cluster</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-releases"><a class="header" href="#binary-releases">Binary Releases</a></h1>
<p>Oura can be ran as a standalone executable. Follow the instructions for your particular OS / Platform to install a local copy from our Github pre-built releases.</p>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>Use the following command to download and install <em>Oura's</em> binary release for MacOS:</p>
<pre><code class="language-sh">curl --silent --location https://git.io/JD2iH | \
    tar xz -C /tmp &amp;&amp; mv /tmp/oura /usr/local/bin
</code></pre>
<h2 id="gnulinux"><a class="header" href="#gnulinux">GNU/Linux</a></h2>
<p>Use the following command to download and install <em>Oura's</em> binary release for GNU/Linux:</p>
<pre><code class="language-sh">curl --silent --location https://git.io/JD2ix | \
    tar xz -C /tmp &amp;&amp; mv /tmp/oura /usr/local/bin
</code></pre>
<p>Check the <a href="https://github.com/txpipe/oura/releases/latest">latest release</a> for more binary download options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-source"><a class="header" href="#from-source">From Source</a></h1>
<p>The following instructions show how to build and install <em>Oura</em> from source code.</p>
<h2 id="pre-requisites"><a class="header" href="#pre-requisites">Pre-requisites</a></h2>
<ul>
<li>Rust toolchain</li>
</ul>
<h2 id="procedure"><a class="header" href="#procedure">Procedure</a></h2>
<pre><code>git clone git@github.com:txpipe/oura.git
cd oura
cargo install --path .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<p><em>Oura</em> provides already built public Docker images through Github Packages. To execute <em>Oura</em> via Docker, use the following command:</p>
<pre><code class="language-sh">docker run ghcr.io/txpipe/oura:latest
</code></pre>
<p>The result of the above command should show <em>Oura's</em> command-line help message.</p>
<h2 id="entry-point"><a class="header" href="#entry-point">Entry Point</a></h2>
<p>The entry-point of the image points to <em>Oura</em> executable. You can pass the same command-line arguments that you would pass to the binary release running bare-metal. For example:</p>
<pre><code>docker run -it ghcr.io/txpipe/oura:latest \
    watch relays-new.cardano-mainnet.iohk.io:3001 \
    --bearer tcp
</code></pre>
<p>For more information on available command-line arguments, check the <a href="installation/../usage/index.html">usage</a> section.</p>
<h2 id="using-a-configuration-file"><a class="header" href="#using-a-configuration-file">Using a Configuration File</a></h2>
<p>The default daemon configuration file for <em>Oura</em> is located in <code>/etc/oura/daemon.toml</code>. To run <em>Oura</em> in daemon mode with a custom configuration file, you need to mount it in the correct location. The following example runs a docker container in background using a configuration file named <code>daemon.toml</code> located in the current folder:</p>
<pre><code>docker run -d -v $(pwd)/daemon.toml:/etc/oura/daemon.toml \
    ghcr.io/txpipe/oura:latest daemon
</code></pre>
<h2 id="versioned-images"><a class="header" href="#versioned-images">Versioned Images</a></h2>
<p>Images are also tagged with the corresponding version number. It is highly recommended to use a fixed image version in production environments to avoid the effects of new features being included in each release (please remember Oura hasn't reached v1 stability guarantees).</p>
<p>To use a versioned image, replace the <code>latest</code> tag by the desired version with the <code>v</code> prefix. For example, to use version <code>0.3.7</code>, use the following image:</p>
<pre><code>ghcr.io/txpipe/oura:v0.3.7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h1>
<p><em>Oura</em> running in <code>daemon</code> mode can be installed can be deployed in Kuberentes cluster, Depending on your needs, we recommend any of the following approaches.</p>
<h2 id="approach-1-sidecar-container"><a class="header" href="#approach-1-sidecar-container">Approach #1: Sidecar Container</a></h2>
<p><em>Oura</em> can be loaded as a sidecar container in the same pod as your Cardano node. Since containers in a pod share the same file-system layer, it's easy to point <em>Oura</em> to the unix-socket of the node.</p>
<p>In the following example yaml, we show a redacted version of a Cardano node resource defined a s Kubernetes STS. Pay attention on the extra container and to the volume mounts to share the unix socket.</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cardano-node
spec:
  
  # REDACTED: here goes your normal cardano node sts / deployment spec

  template:
    spec:
      
      # REDACTED: here goes your normal cardano node pod specs

      containers:
      - name: main
        
        # REDACTED: here goes your normal cardano node container properties

        # add a new volume mount to enable the socket to be
        # consumed by the 2nd container in the pod (Oura)
        volumeMounts:
        - mountPath: /opt/cardano/cnode/sockets/node0.socket
          name: unix-socket

      # add a 2nd container pointing to the _Oura_ image
      - name: oura
        image: ghcr.io/txpipe/oura:latest

        # we mount the same volume that the main container uses as the source
        # for the Cardano node unix socket.
        volumeMounts:
        - mountPath: /opt/cardano/cnode/sockets/node0.socket
          name: unix-socket
        - mountPath: /etc/oura
          name: oura-config

      volumes:

      # REDACTED: here goes any required volume for you normal cardano node setup

      # empty-dir volume to share the unix socket between containers
      - name: unix-socket
        emptyDir: {}

      # a config map resource with Oura's config particular for your requirements
      - name: oura-config
        configMap:
          name: oura-config
</code></pre>
<h2 id="approach-2-standalone-deployment"><a class="header" href="#approach-2-standalone-deployment">Approach #2: Standalone Deployment</a></h2>
<p><em>Oura</em> can be implemented as a standalone Kubernetes <code>deployment</code> resource. This is useful if your Cardano node is not part of your Kubernetes cluster or if you want to keep your node strictly isolated from the access of a sidecard pod.</p>
<p>Please note that the amount of replicas is set to <code>1</code>. <em>Oura</em> doesn't have any kind of &quot;coordination&quot; between instances. Adding more than one replica will just create extra pipelines duplicating the same work.</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: oura
data:
  daemon.toml: |-
    [source]
    # REDACTED: here goes your `source` configuration options

    [[filters]]
    # REDACTED: here goes your `filters` configuration options

    [sink]
    # REDACTED: here goes your `sink` configuration options
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: oura
  labels:
    app: oura
spec:
  replicas: 1
  selector:
    matchLabels:
      app: oura
  template:
    metadata:
      labels:
        app: oura
    spec:
      containers:
      - name: main
        image: ghcr.io/txpipe/oura:latest
        env:
          - name: &quot;RUST_LOG&quot;
            value: &quot;info&quot;
        resources:
          requests:
            memory: 50Mi
            cpu: 50m
          limits:
            memory: 200Mi
            cpu: 200m
        args:
          - &quot;daemon&quot;
        volumeMounts:
          - mountPath: /etc/oura
            name: config
      volumes:
      - name: config
        configMap:
          name: oura
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-mode"><a class="header" href="#watch-mode">Watch Mode</a></h1>
<p>The <code>watch</code> mode provides a quick way to tail the latest events from the blockchain. It connects directly to a Cardano node using either node-to-client or node-to-node protocols. The output is sent into the terminal in a human-readable fashion.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>To start <em>Oura</em> in watch mode, use the following command from your terminal:</p>
<pre><code>oura watch [OPTIONS] &lt;socket&gt;
</code></pre>
<ul>
<li><code>&lt;socket&gt;</code>: this a required argument thats specifies how to connect to the cardano node. It can either be a tcp address (<code>&lt;host&gt;:&lt;port&gt;</code> syntax) or a file path pointing to the location of the unix socket.</li>
</ul>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<ul>
<li><code>--bearer &lt;bearer&gt;</code>: an option that specifies the type of bearer to use. Possible values are <code>tcp</code> and <code>unix</code>. If ommited, the value <code>unix</code> is used as default.</li>
<li><code>--magic &lt;magic&gt;</code>: the magic number of the network you're connecting to. Possible values are <code>mainnet</code>, <code>testnet</code> or a numeric value. If ommited, the value <code>mainnet</code> is used as default.</li>
<li><code>--mode &lt;mode&gt;</code>: an option to force the which set of mini-protocols to use when connecting to the Cardano node. Possible values: <code>node</code> and <code>client</code>.  If ommited, <em>Oura</em> will infer the standard protocols for the specified bearer.</li>
<li><code>--since &lt;slot&gt;,&lt;hash&gt;</code>: an option to specify from which point in the chain <em>Oura</em> should start reading from. The point is referenced by passing the slot of the block followed by a comma and the hash of the block (<code>&lt;slot&gt;,&lt;hash&gt;</code>). If ommited, <em>Oura</em> will start reading from the tail (tip) of the node.</li>
</ul>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="watch-live-data-from-a-remote-relay-node"><a class="header" href="#watch-live-data-from-a-remote-relay-node">Watch Live Data From A Remote Relay Node</a></h3>
<pre><code class="language-sh">oura watch relays-new.cardano-mainnet.iohk.io:3001 --bearer tcp
</code></pre>
<h3 id="watch-live-data-from-a-local-node-via-unix-socket"><a class="header" href="#watch-live-data-from-a-local-node-via-unix-socket">Watch Live Data From A Local Node Via Unix Socket</a></h3>
<pre><code class="language-sh">oura watch /opt/cardano/cnode/sockets/node0.socket --bearer unix
</code></pre>
<h3 id="watch-live-data-from-the-tip-of-a-local-testnet-node"><a class="header" href="#watch-live-data-from-the-tip-of-a-local-testnet-node">Watch Live Data From The Tip Of A Local Testnet Node</a></h3>
<pre><code class="language-sh">oura watch /opt/cardano/cnode/sockets/node0.socket --bearer unix --magic testnet
</code></pre>
<h3 id="watch-data-starting-at-a-particular-block"><a class="header" href="#watch-data-starting-at-a-particular-block">Watch Data Starting At A Particular Block</a></h3>
<pre><code class="language-sh">oura watch relays-new.cardano-mainnet.iohk.io:3001 \
    --bearer tcp \
    --since 49159253,d034a2d0e4c3076f57368ed59319010c265718f0923057f8ff914a3b6bfd1314
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="daemon-mode"><a class="header" href="#daemon-mode">Daemon Mode</a></h1>
<p><em>Oura's</em> <code>daemon</code> mode processes data in the background, without any live output. This mode is used in scenarios where you need to continuosuly bridge blockchain data with other persistence mechanisms or to trigger an automated process in response to a particular event pattern.</p>
<h2 id="start-daemon-mode"><a class="header" href="#start-daemon-mode">Start Daemon Mode</a></h2>
<p>To start <em>Oura</em> in <em>daemon mode</em>, use the following command: </p>
<pre><code>oura dameon
</code></pre>
<p>By default, <em>Oura</em> will load the configuration values from <code>/etc/oura/daemon.toml</code>.</p>
<p>If you need to specify a different configuration path, use the following command:</p>
<pre><code class="language-sh">oura daemon --config my_config.toml
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The configuration file needs to specify the source, filters and sink to use in a particular pipeline. The following toml represent the typical skeleton of an <em>Oura</em> config file:</p>
<pre><code class="language-toml">[source]
type = &quot;X&quot; # the type of source to use

# custom config fields for this source type
foo = &quot;abc&quot;
bar = &quot;xyz&quot;

[[filters]]
type = &quot;Y&quot; # the type of filter to use

# custom config fields for this filter type
foo = &quot;123&quot;
bar = &quot;789&quot;

[sink]
# the type of sink to use
type = &quot;Z&quot;

# custom config fields for this sink type
foo = &quot;123&quot;
bar = &quot;789&quot;
</code></pre>
<h3 id="the-source-section"><a class="header" href="#the-source-section">The <code>source</code> section</a></h3>
<p>This section specifies the origin of the data. The special <code>type</code> field must always be present and containing a value matching any of the available built-in sources. The rest of the fields in the section will depend on the selected <code>type</code>. See the <a href="usage/../sources/index.html">sources</a> section for a list of available options and their corresponding config values.</p>
<h3 id="the-filters-section"><a class="header" href="#the-filters-section">The <code>filters</code> section</a></h3>
<p>This section specifies a collection of filters that are applied in sequence to each event. The sepcial <code>type</code> field must always be present and containing a value matching any of the available built-in filters. Notice that this section of the config is an array, allowing multiple filter sections per config file. See the <a href="usage/../filters/index.html">filters</a> section for a list of available options and their corresponding config values.</p>
<h3 id="the-sink-section"><a class="header" href="#the-sink-section">The <code>sink</code> section</a></h3>
<p>This section specifies the destination of the data. The special <code>type</code> field must always be present and containing a value matching any of the available built-in sinks. The rest of the fields in the section will depend on the selected <code>type</code>. See the <a href="usage/../sinks/index.html">sinks</a> section for a list of available options.</p>
<h3 id="full-example"><a class="header" href="#full-example">Full Example</a></h3>
<p>Here's an example configuration file that uses a Node-to-Node source and output the events into a Kafka sink:</p>
<pre><code class="language-toml">[source]
type = &quot;N2N&quot;
address = [&quot;Tcp&quot;, &quot;relays-new.cardano-mainnet.iohk.io:3001&quot;]
magic = &quot;mainnet&quot;

[[filters]]
type = &quot;Fingerprint&quot;

[[filters]]
type = &quot;Selection&quot;
predicate = &quot;variant_in&quot;
argument = [&quot;Block&quot;, &quot;Transaction&quot;]

[sink]
type = &quot;Kafka&quot;
brokers = [&quot;127.0.0.1:53147&quot;]
topic = &quot;testnet&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library"><a class="header" href="#library">Library</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filters"><a class="header" href="#filters">Filters</a></h1>
<p><em>Filters</em> are intermediate steps in the pipeline that process events as they travel from <em>sources</em> to <em>sinks</em>. They might serve different pourposes, such as: selecting relevant events, enriching event data, transforming data representation, etc.</p>
<h2 id="built-in-filters"><a class="header" href="#built-in-filters">Built-in Filters</a></h2>
<p>These are the existing filters that are included as part the main <em>Oura</em> codebase:</p>
<ul>
<li><a href="filters/fingerprint.html">Fingerprint</a>: a filter that adds a (probably) unique identifier (fingerprint) to each event.</li>
<li><a href="filters/selection.html">Selection</a>: a filter that evaluates different built-in predicates to decide which events should go through the pipeline.</li>
</ul>
<p>New filters are being developed, information will be added in this documentation to reflect the updated list. Contributions and feature request are welcome in our <a href="https://github.com/txpipe/oura">Github Repo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fingerprint-filter"><a class="header" href="#fingerprint-filter">Fingerprint Filter</a></h1>
<p>A filter that computes a (probably) unique identifier for each event and appends it as part of the data passed forward.</p>
<p>Dealing with duplicated records is a common problem in data pipelines. A common workaround is to use identifiers based on the hash of the data for each record. In this way, a duplicated record would yield the same hash, allowing the storage engine to discard the extra instance.</p>
<p>The <em>fingerprint</em> filter uses the non-cryptographic hash algorithm <code>murmur3</code> to compute an id for each <em>Oura</em> event with a very low collision level. We use a non-cryptographic hash because they are faster to compute and non of the cryptographic properties are required for this use-case.</p>
<p>When enabled, this filter will set the <code>fingerprint</code> property of the <code>Event</code> data structure passed through each stage of the pipeline. <em>Sinks</em> at the end of the process might leverage this value as primary key of the corresponding storage mechanism.</p>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>Adding the following section to the daemon config file will enable the filter as part of the pipeline:</p>
<pre><code class="language-toml">[[filters]]
type = &quot;Fingerprint&quot;
</code></pre>
<h3 id="section-filter"><a class="header" href="#section-filter">Section: <code>filter</code></a></h3>
<ul>
<li><code>type</code>: the literal value <code>Fingerprint</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="selection-filter"><a class="header" href="#selection-filter">Selection Filter</a></h1>
<p>A filter that evaluates a set of configurable predicates against each event in the pipeline to decide which records should be sent to the following stage. </p>
<p>Not every use-case requires each and every event to be processed. For example, a pipeline interested in creating a 'metadata' search engine might not care about transactions outputs. With a similar logic, a pipeline aggregating transaction amounts might not care about metadata. The <em>selection filter</em> provides a way to optimize the pipeline so that only relevant events are processed.</p>
<p>The filter works by evaluating a predicate against each event. If the predicate returns <code>true</code>, then the event will continue down the pipeline. If the predicate evalutes to <code>false</code>, the event will be dopped. We currently provide some common built-in predicate to facilitate common use-cases (eg: matching event type, matching policy id, matching a metadata key, etc). We also include some 'connecting' predicates (and / or / not) which can be used to create complex conditions by composing other predicates.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>Adding the following section to the daemon config file will enable the filter as part of the pipeline:</p>
<pre><code class="language-toml">[[filters]]
type = &quot;Selection&quot;

[filters.check]
predicate = &quot;&lt;predicate kind&gt;&quot;
argument = &lt;predicate argument&gt;
</code></pre>
<h3 id="section-filters"><a class="header" href="#section-filters">Section: <code>filters</code></a></h3>
<ul>
<li><code>type</code>: the literal value <code>Selection</code>.</li>
</ul>
<h3 id="section-filterscheck"><a class="header" href="#section-filterscheck">Section <code>filters.check</code></a></h3>
<ul>
<li><code>predicate</code>: the key of the predicate to use for the evaluation. See the list of available predicates for possible values.</li>
<li><code>argument</code>: a polimorphic argument that specializes the behavior of the predicate in some way.</li>
</ul>
<h2 id="available-predicates"><a class="header" href="#available-predicates">Available Predicates</a></h2>
<ul>
<li><code>variant_in (string[])</code>: This predicate will yield true when the variant of the event matches any of the items in the argument array.</li>
<li><code>variant_not_in (string[])</code>: This predicate will yield true when the variant of the event doesn't match any of the items in the argument array.</li>
<li><code>policy_equals (string)</code>: This predicate will yield true when the policy of a mint or output asset matches the value in the argument.</li>
<li><code>asset_equals (string)</code>: This predicate will yield true when the policy of a mint or output asset matches the value in the argument.</li>
<li><code>metadata_key_equals (string)</code>: This predicate will yield true when the root key of a metadata entry matches the value in the argument.</li>
<li><code>metadata_subkey_equals (string)</code>: This predicate will yield true when any of the sub key in a metadata entry matches the value in the argument.</li>
<li><code>not (predicate)</code>: This predicate will yield true when the predicate in the arguments yields false.</li>
<li><code>any_of (predicate[])</code>: This predicate will yield true when <em>any</em> of the predicates in the argument yields true.</li>
<li><code>all_of (predicate[])</code>: This predicate will yield true when <em>all</em> of the predicates in the argument yields true.</li>
</ul>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<p>Allowing only block and transaction events to pass:</p>
<pre><code>[[filters]]
type = &quot;Selection&quot;

[filters.check]
predicate = &quot;variant_in&quot;
argument = [&quot;Block&quot;, &quot;Transaction&quot;]
</code></pre>
<p>Using the <code>not</code> predicate to allow all events except the variant <code>Transaction</code>:</p>
<pre><code>[[filters]]
type = &quot;Selection&quot;

[filters.check]
predicate = &quot;not&quot;

[filters.check.argument]
predicate = &quot;variant_in&quot;
argument = [&quot;Transaction&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sources"><a class="header" href="#sources">Sources</a></h1>
<p>Sources represent the &quot;origin&quot; of the events processed by <em>Oura</em>. Any compatible source is responsible for feeding blockchain data into <em>Oura's</em> pipeline for further processing.</p>
<h2 id="built-in-sources"><a class="header" href="#built-in-sources">Built-in Sources</a></h2>
<p>These are the currently available sources included as part the main <em>Oura</em> codebase:</p>
<ul>
<li><a href="sources/n2n.html">N2N</a>: an Ourboros agent that connects to a Cardano node using node-2-node protocols</li>
<li><a href="sources/n2c.html">N2C</a>: an Ourboros agent that connects to a Cardano node using node-2-client protocols</li>
</ul>
<p>New source are being developed, information will be added in this documentation to reflect the updated list. Contributions and feature request are welcome in our <a href="https://github.com/txpipe/oura">Github Repo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-to-node"><a class="header" href="#node-to-node">Node-to-Node</a></h1>
<p>The Node-to-Node (N2N) source uses Ouroboros mini-protocols to connect to a local or remote Cardano node through a tcp socket bearer and fetches block data using the ChainSync mini-protocol instantiated to &quot;headers only&quot; and the BlockFetch mini-protocol for retrieval of the actual block payload.</p>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>The following snippet shows an example of how to setup a typical N2N source:</p>
<pre><code class="language-toml">[source]
address = [&quot;Tcp&quot;, &quot;&lt;hostname:port&gt;&quot;]
magic = &lt;network magic&gt;
since = [&lt;slot&gt;, &quot;&lt;block hash&gt;&quot;]

[source.mapper]
include_transaction_details = &lt;bool&gt;
</code></pre>
<h3 id="section-source"><a class="header" href="#section-source">Section <code>source</code>:</a></h3>
<ul>
<li><code>type</code>: this field must be set to the literal value <code>N2N</code></li>
<li><code>address</code>: a tuple describing the location of the tcp endpoint It must be specified as a string with hostname and port number.</li>
<li><code>magic</code>: the magic of the network that the node is running (<code>mainnet</code>, <code>testnet</code> or a custom numeric value)</li>
<li><code>since</code>: the point in the chain where reading of events should start from. It must be specified as a tuple of slot (integer) and block hash (hex string)</li>
</ul>
<h3 id="section-sourcemapper"><a class="header" href="#section-sourcemapper">Section <code>source.mapper</code></a></h3>
<p>This section provides options to tweak the behaviour of how raw chain data is mapped into <em>Oura</em> events.</p>
<ul>
<li><code>include_transaction_details</code>: instructs the mapper to include all details in the transaction event payload (inputs, outputs, metadata, mint, etc)</li>
</ul>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<p>Connecting to a local Cardano node in mainnet through unix sockets:</p>
<pre><code class="language-toml">[source]
type = &quot;N2N&quot;
address = [&quot;Tcp&quot;, &quot;relays-new.cardano-mainnet.iohk.io:3001&quot;]
magic = &quot;mainnet&quot;
</code></pre>
<p>Connecting to a local Cardano node in testnet through unix sockets:</p>
<pre><code class="language-toml">[source]
type = &quot;N2N&quot;
address = [&quot;Tcp&quot;, &quot;relays-new.cardano-mainnet.iohk.io:3001&quot;]
magic = &quot;testnet&quot;
</code></pre>
<p>Start reading from a particular point in the chain:</p>
<pre><code class="language-toml">[source]
type = &quot;N2C&quot;
address = [&quot;Tcp&quot;, &quot;relays-new.cardano-mainnet.iohk.io:3001&quot;]
magic = &quot;mainnet&quot;
since = [48896539, &quot;5d1f1b6149b9e80e0ff44f442e0cab0b36437bb92eacf987384be479d4282357&quot;]
</code></pre>
<p>Include all details inside the transaction events:</p>
<pre><code class="language-toml">[source]
type = &quot;N2N&quot;
address = [&quot;Tcp&quot;, &quot;relays-new.cardano-mainnet.iohk.io:3001&quot;]
magic = &quot;mainnet&quot;


[source.mapper]
include_transaction_details = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-to-client"><a class="header" href="#node-to-client">Node-to-Client</a></h1>
<p>The Node-to-Client (N2C) source uses Ouroboros mini-protocols to connect to a local Cardano node through a unix socket bearer and fetches block data using the ChainSync mini-protocol instantiated to &quot;full blocks&quot;.</p>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>The following snippet shows an example of how to setup a typical N2C source:</p>
<pre><code class="language-toml">[source]
type = &quot;N2C&quot;
address = [&quot;Unix&quot;, &quot;&lt;socket location&gt;&quot;]
magic = &lt;network magic&gt;
since = [&lt;slot&gt;, &quot;&lt;block hash&gt;&quot;]

[source.mapper]
include_transaction_details = &lt;bool&gt;
</code></pre>
<h3 id="section-source-1"><a class="header" href="#section-source-1">Section <code>source</code>:</a></h3>
<ul>
<li><code>type</code>: this field must be set to the literal value <code>N2C</code></li>
<li><code>address</code>: a tuple describing the location of the socket</li>
<li><code>magic</code>: the magic of the network that the node is running (<code>mainnet</code>, <code>testnet</code> or a custom numeric value)</li>
<li><code>since</code>: the point in the chain where reading of events should start from. It must be specified as a tuple of slot (integer) and block hash (hex string)</li>
</ul>
<h3 id="section-sourcemapper-1"><a class="header" href="#section-sourcemapper-1">Section <code>source.mapper</code></a></h3>
<p>This section provides options to tweak the behaviour of how raw chain data is mapped into <em>Oura</em> events.</p>
<ul>
<li><code>include_transaction_details</code>: instructs the mapper to include all details in the transaction event payload (inputs, outputs, metadata, mint, etc)</li>
</ul>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>Connecting to a local Cardano node in mainnet through unix sockets:</p>
<pre><code class="language-toml">[source]
type = &quot;N2C&quot;
address = [&quot;Unix&quot;, &quot;/opt/cardano/cnode/sockets/node0.socket&quot;]
magic = &quot;mainnet&quot;
</code></pre>
<p>Connecting to a local Cardano node in testnet through unix sockets:</p>
<pre><code class="language-toml">[source]
type = &quot;N2C&quot;
address = [&quot;Unix&quot;, &quot;/opt/cardano/cnode/sockets/node0.socket&quot;]
magic = &quot;testnet&quot;
</code></pre>
<p>Start reading from a particular point in the chain:</p>
<pre><code class="language-toml">[source]
type = &quot;N2C&quot;
address = [&quot;Unix&quot;, &quot;/opt/cardano/cnode/sockets/node0.socket&quot;]
magic = &quot;mainnet&quot;
since = [48896539, &quot;5d1f1b6149b9e80e0ff44f442e0cab0b36437bb92eacf987384be479d4282357&quot;]
</code></pre>
<p>Include all details inside the transaction events:</p>
<pre><code class="language-toml">[source]
type = &quot;N2C&quot;
address = [&quot;Unix&quot;, &quot;/opt/cardano/cnode/sockets/node0.socket&quot;]
magic = &quot;mainnet&quot;


[source.mapper]
include_transaction_details = true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sinks"><a class="header" href="#sinks">Sinks</a></h1>
<p>Sinks are the &quot;destination&quot; of the events processed by <em>Oura</em>. They are the concrete link between the internal representation of the data records and the corresponding external service interested in the data. Typical sinks include: database engines, stream-processing engines, web API calls and FaaS solutions.</p>
<h2 id="built-in-sinks"><a class="header" href="#built-in-sinks">Built-in Sinks</a></h2>
<p>These are the existing sinks that are included as part the main <em>Oura</em> codebase:</p>
<ul>
<li><a href="sinks/terminal.html">Terminal</a>: a sink that outputs events into stdout with fancy coloring</li>
<li><a href="sinks/kafka.html">Kakfa</a>: a sink that sends each event into a Kafka topic</li>
<li><a href="sinks/elastic.html">Elasticsearch</a>: a sink that writes events into an Elasticsearch index or data stream.</li>
</ul>
<p>New sinks are being developed, information will be added in this documentation to reflect the updated list. Contributions and feature request are welcome in our <a href="https://github.com/txpipe/oura">Github Repo</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminal"><a class="header" href="#terminal">Terminal</a></h1>
<p>A sink that outputs each event into the terminal throught stdout using fancy coloring 💅.</p>
<h2 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h2>
<pre><code class="language-toml">[sink]
type = &quot;Terminal&quot;
throttle_min_span_millis = 500
</code></pre>
<ul>
<li><code>type</code> (required): the literal value <code>Terminal</code>.</li>
<li><code>throttle_min_span_millis</code> (optional, default = <code>500</code>): the amount of time (milliseconds) to wait between printing each event into the console. This is used to facilitate the reading for human following the output.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kafka"><a class="header" href="#kafka">Kafka</a></h1>
<p>A sink that implements a <em>Kafka</em> producer. Each event is json-encoded and sent as a message to a single Kafka topic.</p>
<h2 id="configuration-6"><a class="header" href="#configuration-6">Configuration</a></h2>
<pre><code class="language-toml">[sink]
type = &quot;Kafka&quot;
brokers = [&quot;kafka-broker-0:9092&quot;]
topic = &quot;cardano-events&quot;
</code></pre>
<ul>
<li><code>type</code>: the literal value <code>Kafka</code>.</li>
<li><code>brokers</code>: indicates the location of the <em>Kafka</em> brokers within the network. Several hostname:port pairs can be added to the array for a &quot;cluster&quot; scenario.</li>
<li><code>topic</code> this field indicates which <em>Kafka</em> topic to use to send the outbound messages.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="elasticsearch"><a class="header" href="#elasticsearch">Elasticsearch</a></h1>
<p>A sink that outputs events into an Elasticsearch server. Each event is json-encoded and sent as a message to an index or data stream.</p>
<h2 id="configuration-7"><a class="header" href="#configuration-7">Configuration</a></h2>
<pre><code class="language-toml">[sink]
type = &quot;Elastic&quot;
url = &quot;https://localhost:9200&quot;
index = &quot;oura.sink.v0.mainnet&quot;

[sink.credentials]
type = &quot;Basic&quot;
username = &quot;oura123&quot;
password = &quot;my very secret stuff&quot;
</code></pre>
<h3 id="section-sink"><a class="header" href="#section-sink">Section: <code>sink</code></a></h3>
<ul>
<li><code>type</code>: the literal value <code>Elastic</code>.</li>
<li><code>url</code>: the location of the Elasticsearch's API</li>
<li><code>index</code>: the name of the index (or data stream) to store the event documents</li>
</ul>
<h3 id="section-sinkcredentials"><a class="header" href="#section-sinkcredentials">Section: <code>sink.credentials</code></a></h3>
<p>This section configures the auth mechanism against Elasticsearch. You can remove the whole section from the configuration if you want to skip authentication altogether (maybe private cluster without auth?).</p>
<p>We currently only implement <em>basic</em> auth, other mechanisms will be implemented at some point.</p>
<ul>
<li><code>type</code>: the mechanism to use for authentication, only <code>Basic</code> is currenty implemented</li>
<li><code>username</code>: username of the user with access to Elasticsearch </li>
<li><code>password</code>: password of the user with access to Elasticsearch </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-dictionary"><a class="header" href="#data-dictionary">Data Dictionary</a></h1>
<p><em>Oura</em> follows a Cardano chain and outputs events. Each event contains data about itself and about the <em>context</em> in which it occured.</p>
<p>A consumer aggregating a sequence of multiple events will notices redundant / duplicated data. For example, the &quot;block number&quot; value will appeare repeated in the context of every event of the same block. This behavior is intended, making each event a self-contained record is an architectural decision. We favor &quot;consumption ergonomics&quot; over &quot;data normalization&quot;.</p>
<h2 id="available-events"><a class="header" href="#available-events">Available Events</a></h2>
<p>The following list represent the already implemented events. These data structures are represented as an <code>enum</code> at the code level.</p>
<h3 id="rollback-event"><a class="header" href="#rollback-event"><code>RollBack</code> Event</a></h3>
<ul>
<li>block_slot: u64,</li>
<li>block_hash: String,</li>
</ul>
<h3 id="block-event"><a class="header" href="#block-event"><code>Block</code> Event</a></h3>
<ul>
<li>body_size: usize,</li>
<li>issuer_vkey: String,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
</ul>
</li>
</ul>
<h3 id="transaction-event"><a class="header" href="#transaction-event"><code>Transaction</code> Event</a></h3>
<ul>
<li>fee: u64,</li>
<li>ttl: Option<u64>,</li>
<li>validity_interval_start: Option<u64>,</li>
<li>network_id: Option<u32>,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="txinput-event"><a class="header" href="#txinput-event"><code>TxInput</code> Event</a></h3>
<ul>
<li>tx_id: String,</li>
<li>index: u64,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
<li>input_idx: Option<usize>,</li>
</ul>
</li>
</ul>
<h3 id="txoutput-event"><a class="header" href="#txoutput-event"><code>TxOutput</code> Event</a></h3>
<ul>
<li>address: String,</li>
<li>amount: u64,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
<li>output_idx: Option<usize>,</li>
</ul>
</li>
</ul>
<h3 id="outputasset-event"><a class="header" href="#outputasset-event"><code>OutputAsset</code> Event</a></h3>
<ul>
<li>policy: String,</li>
<li>asset: String,</li>
<li>amount: u64,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
<li>output_idx: Option<usize>,</li>
</ul>
</li>
</ul>
<h3 id="metadata-event"><a class="header" href="#metadata-event"><code>Metadata</code> Event</a></h3>
<ul>
<li>key: String,</li>
<li>subkey: Option<String>,</li>
<li>value: Option<String>,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="mint-event"><a class="header" href="#mint-event"><code>Mint</code> Event</a></h3>
<ul>
<li>policy: String,</li>
<li>asset: String,</li>
<li>quantity: i64,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="collateral-event"><a class="header" href="#collateral-event"><code>Collateral</code> Event</a></h3>
<ul>
<li>tx_id: String,</li>
<li>index: u64,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="plutusscriptref-event"><a class="header" href="#plutusscriptref-event"><code>PlutusScriptRef</code> Event</a></h3>
<ul>
<li>data: String</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="stakeregistration-event"><a class="header" href="#stakeregistration-event"><code>StakeRegistration</code> Event</a></h3>
<ul>
<li>credential: StakeCredential</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="stakederegistration-event"><a class="header" href="#stakederegistration-event"><code>StakeDeregistration</code> Event</a></h3>
<ul>
<li>credential: StakeCredential</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="stakedelegation-event"><a class="header" href="#stakedelegation-event"><code>StakeDelegation</code> Event</a></h3>
<ul>
<li>credential: StakeCredential,</li>
<li>pool_hash: String,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="poolregistration-event"><a class="header" href="#poolregistration-event"><code>PoolRegistration</code> Event</a></h3>
<ul>
<li>operator: String,</li>
<li>vrf_keyhash: String,</li>
<li>pledge: u64,</li>
<li>cost: u64,</li>
<li>margin: f64,</li>
<li>reward_account: String,</li>
<li>pool_owners: Vec<String>,</li>
<li>relays: Vec<String>,</li>
<li>pool_metadata: Option<String>,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="poolretirement-event"><a class="header" href="#poolretirement-event"><code>PoolRetirement</code> Event</a></h3>
<ul>
<li>pool: String,</li>
<li>epoch: u64,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="genesiskeydelegation-event"><a class="header" href="#genesiskeydelegation-event"><code>GenesisKeyDelegation</code> Event</a></h3>
<ul>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<h3 id="moveinstantaneousrewardscert-event"><a class="header" href="#moveinstantaneousrewardscert-event"><code>MoveInstantaneousRewardsCert</code> Event</a></h3>
<ul>
<li>from_reserves: bool,</li>
<li>from_treasury: bool,</li>
<li>to_stake_credentials: Option&lt;BTreeMap&lt;StakeCredential, i64&gt;&gt;,</li>
<li>to_other_pot: Option<u64>,</li>
<li>context:
<ul>
<li>block_number: Option<u64>,</li>
<li>slot: Option<u64>,</li>
<li>tx_idx: Option<usize>,</li>
<li>tx_hash: Option<String>,</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guides"><a class="header" href="#guides">Guides</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cardano--kafka"><a class="header" href="#cardano--kafka">Cardano =&gt; Kafka</a></h1>
<p>This guide shows how to leverage <em>Oura</em> to stream data from a Cardano node into a <em>Kafka</em> topic.</p>
<h2 id="about-kafka"><a class="header" href="#about-kafka">About Kafka</a></h2>
<blockquote>
<p>Apache Kafka is a framework implementation of a software bus using stream-processing. It is an open-source software platform developed by the Apache Software Foundation written in Scala and Java. </p>
</blockquote>
<p>Find <a href="https://en.wikipedia.org/wiki/Apache_Kafka">more info</a> about <em>Kafka</em> in wikipedia or visit <em>Kafka's</em> official <a href="https://kafka.apache.org/">website</a></p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>This examples assumes the following prerequisites:</p>
<ul>
<li>A running Cardano node locally accesible via a unix socket.</li>
<li>A Kafka cluster accesible through the network.</li>
<li>An already existing Kafka topic where to output events</li>
<li><em>Oura</em> binary release installed in local system</li>
</ul>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<h3 id="1-create-an-oura-configuration-file-caradno2kafkatoml"><a class="header" href="#1-create-an-oura-configuration-file-caradno2kafkatoml">1. Create an Oura configuration file <code>caradno2kafka.toml</code></a></h3>
<pre><code class="language-toml">[source]
type = &quot;N2C&quot;
address = [&quot;Unix&quot;, &quot;/opt/cardano/cnode/sockets/node0.socket&quot;]
magic = &quot;testnet&quot;

[sink]
type = &quot;Kafka&quot;
brokers = [&quot;kafka-broker-0:9092&quot;]
topic = &quot;cardano-events&quot;
</code></pre>
<p>Some comments regarding the above configuration:</p>
<ul>
<li>the <code>[source]</code> section indicates <em>Oura</em> from where to pull chain data.
<ul>
<li>the <code>N2C</code> source type value tells <em>Oura</em> to get the data from a Cardano node using Node-to-Client mini-protocols (chain-sync instantiated to full blocks).</li>
<li>the <code>address</code> field indicates that we should connect via <code>Unix</code> socket at the specified path. This value should match the location of your local node socket path.</li>
<li>the <code>magic</code> field indicates that our node is running in the <code>testnet</code> network. Change this value to <code>mainnet</code> if appropriate.</li>
</ul>
</li>
<li>the <code>[sink]</code> section tells <em>Oura</em> where to send the information it gathered.
<ul>
<li>the <code>Kafka</code> sink type value indicates that <em>Oura</em> should use a <em>Kafka</em> producer client as the output</li>
<li>the <code>brokers</code> field indicates the location of the <em>Kafka</em> brokers within the network. Several hostname:port pairs can be added to the array for a &quot;cluster&quot; scenario.</li>
<li>the <code>topic</code> fields indicates which <em>Kafka</em> topic to used for the outbound messages.</li>
</ul>
</li>
</ul>
<h3 id="2-run-oura-in-daemon-mode"><a class="header" href="#2-run-oura-in-daemon-mode">2. Run <em>Oura</em> in <code>daemon</code> mode</a></h3>
<p>Run the following command from your terminal to start the daemon process:</p>
<pre><code class="language-sh">RUST_LOG=info oura daemon --config cardano2kafka.toml
</code></pre>
<p>You should see an output similar to the following:</p>
<pre><code>[2021-12-13T22:16:43Z INFO  oura::sources::n2n::setup] handshake output: Accepted(7, VersionData { network_magic: 764824073, initiator_and_responder_diffusion_mode: false })
[2021-12-13T22:16:43Z INFO  oura::sources::n2n::setup] chain point query output: Some(Tip(Point(47867448, &quot;f170baa5702c91b23580291c3a184195df7c77d3e1a03b3d6424793aacc850d6&quot;), 6624258))
[2021-12-13T22:16:43Z INFO  oura::sources::n2n::setup] node tip: Point(47867448,&quot;f170baa5702c91b23580291c3a184195df7c77d3e1a03b3d6424793aacc850d6&quot;)
[2021-12-13T22:16:44Z INFO  oura::sources::n2n] rolling block to point Point(47867448, &quot;f170baa5702c91b23580291c3a184195df7c77d3e1a03b3d6424793aacc850d6&quot;)
[2021-12-13T22:16:52Z INFO  oura::sources::n2n] requesting block fetch for point Some(Point(47867448, &quot;f170baa5702c91b23580291c3a184195df7c77d3e1a03b3d6424793aacc850d6&quot;))
[2021-12-13T22:17:15Z INFO  oura::sources::n2n] requesting block fetch for point Some(Point(47867448, &quot;f170baa5702c91b23580291c3a184195df7c77d3e1a03b3d6424793aacc850d6&quot;))
[2021-12-13T22:17:20Z INFO  oura::sources::n2n] requesting block fetch for point Some(Point(47867448, &quot;f170baa5702c91b23580291c3a184195df7c77d3e1a03b3d6424793aacc850d6&quot;))
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
